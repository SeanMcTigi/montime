#!/bin/bash
#
# This file is part of montime
# https://github.com/seanmctigi/montime
#
# montime is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# montime is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with montime.  If not, see <http://www.gnu.org/licenses/>.


# Constants --------------------------------------------------------------------
#
# you may overwrite all this constants in
#   ~/.montime/montimerc
# and/or
#   ~/.montime/profiles/<profile>
#

DEBUG=0                                         # debug level 0-3
DISPLAY=:0.0 					# if we are launching from cron, 
						#  we need to tell it which display to use
E_NOARGS=65                                     # standard errorlevel definition
LOGFILE=montime.log 
PID=$$                                          # montime's pid
PROFILEDIR="$HOME/.montime"                     # profiledir
PROFILE=~/.montime
TMPDIR=/tmp                                     # here to put temporary files
VERBOSE=0                                       # verbosity level

# define all binaries
BIN_STREAMRIPPER=$(which streamripper)


# Variables --------------------------------------------------------------------
PostExit=0                                      # Used for delayed shutdown's



# ------------------------------------------------------------------------------
# Functions 
# 
# functions are sorted in an alphabetical order
#

# ------------------------------------------------------------------------------
check_requirements()
# ------------------------------------------------------------------------------
#
# Description:  Check if all necessary tools and binaries are available
#
# Parameter  :  none
#
# Output     :  logging
#               forces an error if a needed binary is not available
#
{
if [ $DEBUG -ge 3 ]; then set -x
fi

logging -d "checking montime requirements"
if [ -z $BIN_STREAMRIPPER ]; then RequirementsMsg=streamripper
fi

if [ ! -z $RequirementsMsg ];
then
  logging -e "Program $RequirementsMsg not installed or not in PATH"
  return 1
fi

if [ ! -w "$WORKDIR" ];
then
  logging -e "Cannot write into $WORKDIR directory"
  return 1
fi

return 0
}

# ------------------------------------------------------------------------------
config-read()
# ------------------------------------------------------------------------------
#
# Description:  read all config data from config file
#
# Parameter  :  none
#
# Output     :  logging
#
{
i=0
while read line; do
  if [[ "$line" =~ ^[^#]*= ]]; then
    item[i]=${line%%=*}
    value[i]=${line#*=}
    ((i++))
  fi
done < conf

# debug info:
#echo "total array elements: ${#item[@]}"
#echo "item array: ${item[@]}"
}


# ------------------------------------------------------------------------------
control_c()
# ------------------------------------------------------------------------------
#
# Description:  run if user hits control-c
#
# Parameter  :  none
#
# Output     :  logging
#
{
if [ $DEBUG -ge 3 ]; then set -x
fi

echo ""
logging -n "CTRL-C catched"
shutdown_montime 0
}

# ------------------------------------------------------------------------------
daemon_loop()
# ------------------------------------------------------------------------------
{
  while true; do
    if [[ $(gnome-screensaver-command -q | head -1) =~ "inactive" ]]
    then
      windowid=`xdotool getwindowfocus`
      if [ "$windowid" == "" ]; then
        windowclass='"unknown", "unknown"'
        windowtitle='"unknown"'
      else
        windowclass=`xprop -id $windowid | grep WM_CLASS | sed -e 's/WM_CLASS(STRING) = //'`
        if [ "$windowclass" == "" ]; then
          windowclass='"unknown", "unknown"'
        fi
        windowtitle=`xprop -id $windowid | grep "WM_NAME(STRING)" | sed -e 's/WM_NAME(STRING) = //'`
        if [ "$windowtitle" == "" ]; then
          windowtitle='"unknown"'
        fi
      fi
      line="`date +%Y-%m-%d`, $windowclass, $windowtitle"
    else
      line=`date +%Y-%m-%d`', "inactive", "inactive", "inactive"'
    fi

    #escape pipe char
    #TODO: find a better way to escape pipe char, should be unchanged in logfile
    line=`echo "$line" | awk  '{gsub(/\|/,"\\\|"); print}'`

    #escape & char
    #TODO: find a better way to escape & char, should be unchanged in logfile
    line=`echo "$line" | awk  '{gsub(/\&/,"+"); print}'`

    pos=`grep -F "$line" "$PROFILE/$LOGFILE" | wc -l`
    if [ $pos -eq 0 ]; then
      newline="$line, 1"
      echo "$newline" >> "$PROFILE/$LOGFILE"
    else
      oldline=`grep -F "$line" $PROFILE/$LOGFILE`
      newline=`echo "$oldline" | awk '{$NF=$NF+1; print $0}'`
      sedeasy "$oldline" "$newline" "$PROFILE/$LOGFILE"
    fi
    echo $newline

    sleep 1
  done
}

# ------------------------------------------------------------------------------
logging()
# ------------------------------------------------------------------------------
#
# Description:  It writes messages to logfile or standard output.
#
# Parameter  :  $1 - the level of message
#               $2 - the message
#
# Std. Output:  Logging messages.
#
{
 if [ $DEBUG -ge 3 ]; then set -x
 fi

 logtime="$(date +%H):$(date +%M):$(date +%S)"
 prefix=""
 stderr=-1
 verbose=0

 case $1 in
   -e)     prefix="Error:   " stderr=1 verbose=0;;
   -i)     prefix="Info:    " stderr=0 verbose=0;;
   -n)     prefix="Notice:  " stderr=0 verbose=1;;
   -s)     prefix="Success: " stderr=0 verbose=0;;
   -w)     prefix="Warning: " stderr=1 verbose=1;;
   -d)     prefix="Debug:   " stderr=1 verbose=2;;
 esac
 shift

# if VERBOSE mode is set, then show all messages, which we want to show in verbose mode
if [ $verbose -ge 1 ] && [ $VERBOSE -ge 1 ] ; then
 if [ "$stderr" -eq 1 ]; then
   echo "$logtime $prefix" $1 >&2
 else
   echo "$logtime $prefix" $1
 fi
# else show only messages which are defined to show in non-verbose mode
elif [ $verbose -eq 0 ] ; then
 if [ "$stderr" -eq 1 ]; then
   echo "$logtime $prefix" $1 >&2
 else
   echo "$logtime $prefix" $1
 fi
fi
}


# ------------------------------------------------------------------------------
process-time()
# ------------------------------------------------------------------------------
#
# Description:  Count and print the times of a project
#
# Parameter  :  $1 - project name
#               $2 - data
#               $3 - comment
#               $4 - billable
#               $5 - filters (array by name)
#
# Std. Output:  Time values of project
#
{ 
  #echo "processing project: $1"
  #echo "total array elements: ${#filter[@]}"
  #echo "filter array: ${filter[@]}"
  hours=0
  for (( v=0; v<${#filter[@]}; v++ ))
  do
    h=$(awk "/$2/&&/${filter[v]}/" montime.log | awk '{ sum+=$NF } END { printf("%.2f\n",sum/3600)}')
    hours=$(echo $hours + $h | bc)
  done
  if [ "$hours" != "0" ];
  then
    printf "%s: %.2f\n" "$1" "$hours"
  fi
  totalhours=$(echo $totalhours + $hours | bc)
}

# ------------------------------------------------------------------------------
process-unmatched()
# ------------------------------------------------------------------------------
#
# Description:  Count and print the times of all logged entries which are not related to a project
#
# Parameter  :  none
#
# Std. Output:  Time values of unmatched log entries
#
{

# get all filters
unset filter
i=1
for (( c=0; c<${#item[@]}; c++ ))
do
  case "${item[$c]}" in
    filter)
        if [ "$i" == "1" ];
        then
          filter="(/2014-02-25/)&&(\$0 !~ /${value[$c]}/)"
          ((i++))
        else
          filter="$filter&&(\$0 !~ /${value[$c]}/)"
        fi
        ;;
  esac
done
h=$(awk "$filter" montime.log | awk '{ sum+=$NF } END { printf("%.2f\n",sum/3600)}')
printf "%s: %.2f\n" "Total unmatched time" "$h"
echo
echo "all unmatched:"
awk "$filter" montime.log
}


# ------------------------------------------------------------------------------
resetvars()
# ------------------------------------------------------------------------------
#
# Description:  reset variables
#
# Parameter  :  none
#
# Output     :  none
#
{
unset project
unset comment
unset billable
unset filter
unset active
f=0
}


show-project-stats()
{
totalhours=0
resetvars

for (( c=0; c<${#item[@]}; c++ ))
do
  # debug info:
  #  echo "${item[$c]}=${value[$c]}"
  case "${item[$c]}" in
    data)
        data="${value[$c]}"
        if [ "$data" == "today" ]; then
          data=`date +%Y-%m-%d`
        fi
        ;;
    project)
        project="${value[$c]}"
        ;;
    comment)
        comment="${value[$c]}"
        ;;
    billable)
        billable="${value[$c]}"
        ;;
    filter)
        filter[f]="${value[$c]}"
        ((f++))
        ;;
    active)
        if [ "${value[$c]}" == "1" ] ;
        then
          #echo "Project:  $project"
          #echo "Data:     $data"
          #echo "Comment:  $comment"
          #echo "Billable: $billable"
          #echo "Filter:   $filter"
          #echo "-----------------------"
          timeprocessing "$project" "$data" "$comment" "$billable" filter
        fi
        resetvars
        ;;
  esac
done
echo "Total Hours:  $totalhours"

}

# ------------------------------------------------------------------------------
shutdown_montime()
# ------------------------------------------------------------------------------
#
# Description:  shutting down montime and cleaning up
#
# Parameter  :  none
#
# Output     :  logging
#
{
if [ $DEBUG -ge 1 ]; then set -x
fi

logging -n "Shutting down montime..."
ExitCode=$1

case $ExitCode in
        0)
          logging -s "montime stopped."
        ;;
        1)
          logging -w "montime stopped partionally unsuccuessfull"
        ;;
esac
logging -a "Returnvalue=$ExitCode"

exit $ExitCode
}


# ------------------------------------------------------------------------------
usage()
# ------------------------------------------------------------------------------
#
# Description:  shows help text
#
# Parameter  :  none
#
# Output     :  shows help text
#
{
cat << EOF

usage: 
   $0 -d
or
   $0 -l

OPTIONS:
  -d    Daemon mode for logging in the background
  -h    Show this message
  -s    show stats of matched log entries, categories, projects
  -u    show stats of unmatched log entries
  -q    Quiet
  -v    Verbose, verbosity level 0|1|2|3 (level 0 is standard, -v without number is like 1)

EOF
return 0
}

# ------------------------------------------------------------------------------
function sedeasy {
#  sed -i "s/$(echo $1 | sed -e 's/\([[\/.*]\|\]\)/\\&/g')/$(echo $2 | sed -e 's/[\/&]/\\&/g')/g" $3
  oldsed=$(echo "$1" | sed -e 's/[]\/$*.^[]/\\&/g')
  newsed=$(echo "$2" | sed -e 's/[]\/$*.^[]/\\&/g')
  sed -i "s/$oldsed/$newsed/g" $3
}


# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------

# trap keyboard interrupt (control-c)
trap control_c SIGINT

if [ ! -d "$PROFILE" ]; then
  mkdir -p "$PROFILE"
  touch "$PROFILE/$LOGFILE"
fi

# When you need an argument that needs a value, you put the ":" right after
# the argument in the optstring. If your var is just a flag, withou any
# additional argument, just leave the var, without the ":" following it.
#
# please keep letters in alphabetic order
#
while getopts "dhqv" OPTION
do
  case $OPTION in
    d)
      daemon_loop
      exit 0
      ;;
    h)
      usage
      exit 0
      ;;
    q)
      DEBUG=0
      VERBOSE=0
      # add LOGGING variable and change logging function to be able to turn
      # all output off
      ;;
    s)
      ;;
    u)
      ;;
    v)
      VERBOSE=1
      ;;
    \?)
      logging -e "Invalid option: -$OPTARG" >&2
      usage
      shutdown_montime 1
      ;;
    :)
      logging -e "Option -$OPTARG requires an argument." >&2
      shutdown_montime 1
      ;;
  esac
done


